My current homebrew at 1AM search algorythm does this:

First, checks for tag matching.
Match rate is calculated as query_tag.length / tag.length
    only when query_tag is found within tag
And i mean tag names, no descriptions included.
This rate is called $likeliness

This results a pair of tag_name => rate, which we sort
in array of [tag, rate]. From largest to lowest rate.

Then it finds all resources for tags with rate above 0
And adds to their own rate (which starts as 0) this:
(tag_rate / tag_rates_sum)

After that i iterate all resources, multiplying their
rate by sqrt($val["tags"] / $val["total_tags"]).
This was done because i want resources with a lot of
tags to get lower rating than these with less tags.
The square root makes the algorythm less drastic.

Finally, we sort the resources by their rates,
and return first N with rate between the maximum one
and one quarter of it.

N being a hard-coded 100, because i'm tired.


Underline note:

I do not have any idea how to do the sqrt part better
 right now, and i do understand that querying all tags,
 almost all linked resources and their own tags one by
 one is really bad idea, but that's as much as i can do
 with my current phase of my Core framework, and mixing
 SQL inside my code is bad practice for long-supporting.

This thing really needs some work thrown in. But knowing
 myself, i'll most likely not come here anytime soon.
 If you read this, and still want to try to make me fix
 my own mistakes, feel free to ping me in Github or
 whatever place i uploaded this source code.
